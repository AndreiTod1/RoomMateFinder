@page "/conversations/{ConversationId:guid}"
@using Microsoft.AspNetCore.Authorization
@using RoomMate_Finder_Frontend.Services
@using System.Security.Claims
@attribute [Authorize]
@implements IAsyncDisposable
@inject IConversationService ConversationService
@inject IChatService ChatService
@inject IAuthService AuthService
@inject INotificationService NotificationService
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@inject IConfiguration Configuration
@inject ISnackbar Snackbar
@inject IJSRuntime JSRuntime
@inject IRoommateService RoommateService
@inject IDialogService DialogService

<PageTitle>Chat - RoomMate Finder</PageTitle>

<style>
    .chat-fixed-layout {
        position: fixed;
        top: 64px;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        background-color: #f0f2f5;
        z-index: 5;
    }

    .msg-bubble {
        padding: 10px 16px;
        position: relative;
        font-size: 0.95rem;
        line-height: 1.4;
        max-width: 70%;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    
    .msg-mine {
        background: linear-gradient(135deg, #0084ff 0%, #0078eb 100%);
        color: white;
        border-radius: 18px 18px 4px 18px;
        align-self: flex-end;
    }
    
    .msg-theirs {
        background: white;
        color: #1c1e21;
        border-radius: 18px 18px 18px 4px;
        align-self: flex-start;
    }

    .msg-time {
        font-size: 0.7rem;
        margin-top: 4px;
        opacity: 0.7;
        text-align: right;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 2px;
    }

    .typing-indicator {
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .typing-indicator span {
        width: 8px;
        height: 8px;
        background-color: #90949c;
        border-radius: 50%;
        animation: typing 1.4s infinite ease-in-out both;
    }
    
    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
    
    @@keyframes typing {
        0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
        40% { transform: scale(1); opacity: 1; }
    }

    @@media (min-width: 960px) {
        .chat-fixed-layout { left: 256px; }
    }
</style>

<div class="chat-fixed-layout">
    @if (_isLoading)
    {
        <div class="d-flex align-center justify-center flex-grow-1">
            <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
        </div>
    }
    else if (!string.IsNullOrEmpty(_errorMessage))
    {
        <div class="d-flex flex-column align-center justify-center flex-grow-1 pa-4">
            <MudAlert Severity="Severity.Error">@_errorMessage</MudAlert>
            <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="GoBack" Class="mt-4">Înapoi</MudButton>
        </div>
    }
    else
    {
        <!-- Header -->
        <div class="d-flex align-center px-4 py-2 bg-white" style="border-bottom: 1px solid #e0e0e0; height: 60px; flex-shrink: 0;">
            <MudIconButton Icon="@Icons.Material.Filled.ArrowBack" OnClick="GoBack" Color="Color.Inherit" Class="mr-2" />
            
            <div class="d-flex align-center gap-3 flex-grow-1">
                @if (!string.IsNullOrEmpty(_otherUserProfilePicture))
                {
                    <MudAvatar Size="Size.Medium">
                        <MudImage Src="@GetProfilePictureUrl(_otherUserProfilePicture)" />
                    </MudAvatar>
                }
                else
                {
                    <MudAvatar Color="Color.Primary" Size="Size.Medium">
                        @GetInitials(_otherUserName)
                    </MudAvatar>
                }
                
                <div class="d-flex flex-column">
                    <MudText Typo="Typo.subtitle2" Style="font-weight: 700;">@_otherUserName</MudText>
                    @if (_otherUserIsTyping)
                    {
                        <MudText Typo="Typo.caption" Color="Color.Success" Style="line-height: 1; font-style: italic;">scrie...</MudText>
                    }
                    else if (!string.IsNullOrEmpty(_otherUserRole))
                    {
                        <MudText Typo="Typo.caption" Color="Color.Secondary" Style="line-height: 1;">@_otherUserRole</MudText>
                    }
                </div>
            </div>
            
            <!-- Roommate Request Button -->
            <MudTooltip Text="@GetRoommateButtonTooltip()">
                <MudIconButton Icon="@GetRoommateButtonIcon()" 
                               Color="@GetRoommateButtonColor()" 
                               Size="Size.Medium"
                               OnClick="OpenRoommateRequestDialog"
                               Disabled="@IsRoommateButtonDisabled()" />
            </MudTooltip>
        </div>

        <!-- Messages Area -->
        <div id="messages-container" class="flex-grow-1 overflow-y-auto px-4 py-4 d-flex flex-column gap-2" style="background-color: #f0f2f5;">
            @if (_messages == null || !_messages.Any())
            {
                <div class="d-flex flex-column align-center justify-center flex-grow-1" style="opacity: 0.5;">
                    <MudIcon Icon="@Icons.Material.Filled.Upcoming" Size="Size.Large" />
                    <MudText>Începe conversația!</MudText>
                </div>
            }
            else
            {
                DateTime? lastDate = null;
                @foreach (var msg in _messages.OrderBy(m => m.SentAt))
                {
                    var currentDate = msg.SentAt.ToLocalTime().Date;
                    if (lastDate == null || currentDate != lastDate.Value)
                    {
                        <div class="d-flex justify-center my-3">
                            <span style="font-size: 0.75rem; background: rgba(0,0,0,0.05); padding: 2px 8px; border-radius: 10px; color: #65676b;">
                                @currentDate.ToString("dd MMM")
                            </span>
                        </div>
                        lastDate = currentDate;
                    }

                    var isMine = msg.SenderId == _currentUserId;
                    <div class="msg-bubble @(isMine ? "msg-mine" : "msg-theirs")">
                        @msg.Content
                        <div class="msg-time">
                            @msg.SentAt.ToLocalTime().ToString("HH:mm")
                            @if (isMine)
                            {
                                <MudIcon Icon="@(msg.IsRead ? Icons.Material.Filled.DoneAll : Icons.Material.Filled.Done)" 
                                         Size="Size.Small" 
                                         Style="@($"font-size: 0.9rem; {(msg.IsRead ? "color: #00e676;" : "color: rgba(255,255,255,0.7);")}")" />
                            }
                        </div>
                    </div>
                }
                
                @if (_otherUserIsTyping)
                {
                    <div class="msg-bubble msg-theirs" style="padding: 8px 16px;">
                        <div class="typing-indicator">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    </div>
                }
            }
            <div id="messages-end"></div>
        </div>

        <!-- Input Area -->
        <div class="px-3 py-2 bg-white d-flex align-center gap-2" style="border-top: 1px solid #e0e0e0; flex-shrink: 0;">
            <MudTextField @bind-Value="_newMessage" 
                          Placeholder="Scrie un mesaj..." 
                          Variant="Variant.Outlined" 
                          Margin="Margin.Dense"
                          Class="rounded-pill"
                          Style="background-color: #f0f2f5; border: none;"
                          Immediate="true"
                          TextChanged="OnTextChanged"
                          OnKeyDown="HandleKeyDown"
                          Disabled="_isSending"/>
            
            <MudIconButton Icon="@Icons.Material.Filled.Send" 
                           Color="Color.Primary" 
                           Variant="Variant.Filled" 
                           Size="Size.Medium"
                           OnClick="SendMessage"
                           Disabled="@(string.IsNullOrWhiteSpace(_newMessage) || _isSending)" 
                           Class="rounded-circle" />
        </div>
    }
</div>

@code {
    [Parameter] public Guid ConversationId { get; set; }
    private List<MessageDto>? _messages;
    private string _newMessage = string.Empty;
    private bool _isLoading = true;
    private bool _isSending;
    private string? _errorMessage;
    private string _otherUserName = "Utilizator";
    private string? _otherUserProfilePicture;
    private string? _otherUserRole;
    private Guid _currentUserId;
    private Guid _otherUserId;
    private string _apiBaseUrl = "";
    private bool _otherUserIsTyping;
    private System.Timers.Timer? _typingTimer;
    
    // Roommate request state
    private bool _isRoommate;
    private bool _hasSentPendingRequest;      // Current user sent a pending request
    private bool _hasReceivedPendingRequest;  // Other user sent a pending request to current user
    private bool _hasMutuallyConfirmedRequest; // Both users confirmed, waiting for admin
    private bool _isSendingRequest;

    protected override async Task OnInitializedAsync()
    {
        _apiBaseUrl = Configuration["ApiBaseUrl"] ?? string.Empty;
        await GetCurrentUserId();
        await NotificationService.MarkConversationAsReadAsync(ConversationId);
        await LoadMessages();
        await LoadConversationDetails();
        await LoadRoommateStatus();
        await ConnectToSignalR();
    }

    private async Task GetCurrentUserId()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        if (user.Identity?.IsAuthenticated == true)
        {
            var idClaim = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (Guid.TryParse(idClaim, out var id)) _currentUserId = id;
        }
    }

    private async Task LoadConversationDetails()
    {
        try
        {
            var conversations = await ConversationService.GetConversationsAsync();
            var currentConv = conversations.FirstOrDefault(c => c.Id == ConversationId);
            if (currentConv != null)
            {
                _otherUserName = currentConv.OtherUserName;
                _otherUserProfilePicture = currentConv.OtherUserProfilePicture;
                _otherUserRole = currentConv.OtherUserRole;
                _otherUserId = currentConv.OtherUserId;
                StateHasChanged();
            }
        }
        catch (Exception ex) 
        {
            Console.WriteLine($"Error fetching conversation details: {ex.Message}");
        }
    }

    private async Task LoadRoommateStatus()
    {
        try
        {
            var myRequests = await RoommateService.GetMyRequestsAsync();
            if (myRequests != null)
            {
                // Check if already roommates
                _isRoommate = myRequests.ActiveRoommates.Any(r => r.RoommateId == _otherUserId);
                
                // Check if current user sent a pending request to other user
                _hasSentPendingRequest = myRequests.SentRequests.Any(r => r.OtherUserId == _otherUserId && r.Status == "Pending");
                
                // Check if other user sent a pending request to current user (current user needs to confirm)
                _hasReceivedPendingRequest = myRequests.ReceivedRequests.Any(r => r.OtherUserId == _otherUserId && r.Status == "Pending");
                
                // Check if both have confirmed and waiting for admin approval
                _hasMutuallyConfirmedRequest = myRequests.SentRequests.Any(r => r.OtherUserId == _otherUserId && r.Status == "MutuallyConfirmed")
                                            || myRequests.ReceivedRequests.Any(r => r.OtherUserId == _otherUserId && r.Status == "MutuallyConfirmed");
                
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading roommate status: {ex.Message}");
        }
    }

    private string GetRoommateButtonTooltip()
    {
        if (_isRoommate) return "Sunteți deja colegi de cameră";
        if (_hasMutuallyConfirmedRequest) return "Cerere în așteptarea aprobării de admin";
        if (_hasSentPendingRequest) return "Ai trimis o cerere. Așteaptă ca celălalt utilizator să confirme.";
        if (_hasReceivedPendingRequest) return $"{_otherUserName} ți-a trimis o cerere! Apasă pentru a confirma.";
        return "Trimite cerere de colegiat";
    }

    private Color GetRoommateButtonColor()
    {
        if (_isRoommate) return Color.Success;
        if (_hasMutuallyConfirmedRequest) return Color.Info;
        if (_hasSentPendingRequest) return Color.Warning;
        if (_hasReceivedPendingRequest) return Color.Secondary;
        return Color.Primary;
    }

    private string GetRoommateButtonIcon()
    {
        if (_isRoommate) return Icons.Material.Filled.CheckCircle;
        if (_hasMutuallyConfirmedRequest) return Icons.Material.Filled.HourglassTop;
        if (_hasReceivedPendingRequest) return Icons.Material.Filled.PersonAddAlt1;
        return Icons.Material.Filled.PersonAdd;
    }

    private bool IsRoommateButtonDisabled()
    {
        return _isRoommate || _hasMutuallyConfirmedRequest || _hasSentPendingRequest || _isSendingRequest;
    }

    private async Task OpenRoommateRequestDialog()
    {
        if (_isRoommate || _hasMutuallyConfirmedRequest || _hasSentPendingRequest) return;

        var dialogTitle = _hasReceivedPendingRequest 
            ? "Confirmă cererea de colegiat" 
            : "Trimite cerere de colegiat";
            
        var parameters = new DialogParameters<RoommateRequestDialog>
        {
            { x => x.OtherUserName, _otherUserName },
            { x => x.IsConfirmation, _hasReceivedPendingRequest }
        };

        var dialog = await DialogService.ShowAsync<RoommateRequestDialog>(dialogTitle, parameters);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            var message = result.Data as string;
            await SendRoommateRequest(message);
        }
    }

    private async Task SendRoommateRequest(string? message)
    {
        try
        {
            _isSendingRequest = true;
            StateHasChanged();
            
            var response = await RoommateService.SendRoommateRequestAsync(_otherUserId, message);
            Snackbar.Add(response?.Message ?? "Cerere trimisă cu succes!", Severity.Success);
            
            // Reload roommate status to update UI correctly
            await LoadRoommateStatus();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Eroare: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isSendingRequest = false;
            StateHasChanged();
        }
    }
    private async Task ConnectToSignalR()
    {
        try
        {
            var token = await AuthService.GetTokenAsync();
            if(!string.IsNullOrEmpty(token))
            {
                await ChatService.ConnectAsync(token);
                await ChatService.JoinConversationAsync(ConversationId);
                ChatService.OnMessageReceived += HandleMessageReceived;
                ChatService.OnMessagesRead += HandleMessagesRead;
                ChatService.OnUserTyping += HandleUserTyping;
                ChatService.OnUserStoppedTyping += HandleUserStoppedTyping;
                await ChatService.MarkAsReadAsync(ConversationId);
            }
        }
        catch
        {
            // SignalR connection errors are handled silently - chat will work via REST fallback
        }
    }

    private void HandleUserTyping(Guid conversationId, Guid userId)
    {
        if (conversationId == ConversationId && userId != _currentUserId)
        {
            _otherUserIsTyping = true;
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleUserStoppedTyping(Guid conversationId, Guid userId)
    {
        if (conversationId == ConversationId && userId != _currentUserId)
        {
            _otherUserIsTyping = false;
            InvokeAsync(StateHasChanged);
        }
    }

    private void HandleMessageReceived(ChatMessageDto message)
    {
        if (message.ConversationId == ConversationId)
        {
            _messages ??= new List<MessageDto>();
            _messages.Add(new MessageDto(message.Id, message.SenderId, message.SenderName, message.SenderRole, message.Content, message.SentAt, message.IsRead));
            if (message.SenderId != _currentUserId) _ = ChatService.MarkAsReadAsync(ConversationId);
            InvokeAsync(async () => 
            {
                StateHasChanged();
                await Task.Delay(50);
                await ScrollToBottomAsync();
            });
        }
    }

    private void HandleMessagesRead(Guid conversationId, Guid userId)
    {
        if (conversationId == ConversationId && _messages != null)
        {
            for(int i=0; i<_messages.Count; i++)
            {
                var m = _messages[i];
                if (m.SenderId == _currentUserId && !m.IsRead) _messages[i] = m with { IsRead = true };
            }
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task LoadMessages()
    {
        try
        {
            _isLoading = true;
            _messages = await ConversationService.GetMessagesAsync(ConversationId);
            
            if (string.IsNullOrEmpty(_otherUserName) || _otherUserName == "Utilizator")
            {
                var other = _messages?.FirstOrDefault(m => m.SenderId != _currentUserId);
                if(other != null) 
                { 
                    _otherUserName = other.SenderName; 
                    _otherUserRole = other.SenderRole; 
                }
            }
            await ConversationService.MarkMessagesAsReadAsync(ConversationId);
        }
        catch (Exception ex) { _errorMessage = ex.Message; }
        finally 
        { 
            _isLoading = false;
            StateHasChanged();
            await Task.Delay(100);
            await ScrollToBottomAsync();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_newMessage) || _isSending) return;
        try
        {
            _isSending = true;
            var content = _newMessage.Trim();
            _newMessage = string.Empty;
            if (ChatService.IsConnected) 
            {
                await ChatService.SendMessageAsync(ConversationId, content);
            }
            else
            {
                var sent = await ConversationService.SendMessageAsync(ConversationId, content);
                if (sent != null) 
                { 
                    _messages ??= new List<MessageDto>(); 
                    _messages.Add(sent with { SenderId = _currentUserId, SenderName = "Tu", IsRead = false });
                    StateHasChanged();
                    await Task.Delay(50);
                    await ScrollToBottomAsync();
                }
            }
        }
        catch (Exception ex) { Snackbar.Add(ex.Message, Severity.Error); }
        finally { _isSending = false; }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e) 
    { 
        if (e.Key == "Enter" && !e.ShiftKey) 
        {
            await StopTypingIndicator();
            await SendMessage(); 
        }
    }

    private async Task OnTextChanged(string text)
    {
        _newMessage = text;
        if (!string.IsNullOrEmpty(text))
        {
            await StartTypingIndicator();
        }
    }
    
    private async Task StartTypingIndicator()
    {
        if (ChatService.IsConnected)
        {
            await ChatService.StartTypingAsync(ConversationId);
            _typingTimer?.Stop();
            _typingTimer?.Dispose();
            _typingTimer = new System.Timers.Timer(2000);
            _typingTimer.Elapsed += async (s, e) => await StopTypingIndicator();
            _typingTimer.AutoReset = false;
            _typingTimer.Start();
        }
    }
    
    private async Task StopTypingIndicator()
    {
        _typingTimer?.Stop();
        if (ChatService.IsConnected)
        {
            await ChatService.StopTypingAsync(ConversationId);
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("eval", "document.getElementById('messages-end')?.scrollIntoView({ behavior: 'smooth' })");
        }
        catch
        {
            // Scroll errors can be ignored - UI will still function
        }
    }

    private string GetProfilePictureUrl(string? path)
    {
        if (string.IsNullOrEmpty(path))
            return "";
        if (path.StartsWith("http"))
            return path;
        return $"{_apiBaseUrl}{path}";
    }
    
    private static string GetInitials(string n)
    {
        if (string.IsNullOrEmpty(n)) return "?";
        if (!n.Contains(' ')) return n.Substring(0, Math.Min(2, n.Length)).ToUpper();
        var parts = n.Split(' ');
        return $"{parts[0][0]}{parts[1][0]}".ToUpper();
    }
    private void GoBack() => Navigation.NavigateTo("/conversations");
    
    public async ValueTask DisposeAsync() 
    { 
        _typingTimer?.Stop();
        _typingTimer?.Dispose();
        ChatService.OnMessageReceived -= HandleMessageReceived; 
        ChatService.OnMessagesRead -= HandleMessagesRead; 
        ChatService.OnUserTyping -= HandleUserTyping;
        ChatService.OnUserStoppedTyping -= HandleUserStoppedTyping;
        await ChatService.LeaveConversationAsync(ConversationId); 
    }
}

