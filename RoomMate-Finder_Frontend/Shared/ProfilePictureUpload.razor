@using Microsoft.AspNetCore.Components.Forms
@implements IAsyncDisposable
@inject IJSRuntime JS

<MudPaper Elevation="0" Class="pa-3" Style="border: 2px dashed var(--mud-palette-primary); border-radius: 8px;">
    <MudStack Spacing="2" AlignItems="AlignItems.Center">
        @if (_hasNewImage && !string.IsNullOrEmpty(PreviewUrl))
        {
            <!-- Image Crop Area - only for NEW images -->
            <div class="crop-container" 
                 id="@_containerId"
                 style="position: relative; width: 280px; height: 280px; background: #f5f5f5; border-radius: 8px; overflow: hidden; cursor: grab; user-select: none;"
                 @onmousedown="OnMouseDown"
                 @onmousemove="OnMouseMove"
                 @onmouseup="OnMouseUp"
                 @onmouseleave="OnMouseUp">
                
                <img src="@PreviewUrl" 
                     alt="Profile preview" 
                     id="@_imageId"
                     draggable="false"
                     style="width: @(_scale * 100)%; height: auto; position: absolute; top: @(_imageOffsetY)px; left: @(_imageOffsetX)px; pointer-events: none;" />
                
                <!-- Circular Overlay -->
                <div class="crop-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                    <svg width="100%" height="100%" style="position: absolute;">
                        <defs>
                            <mask id="circleMask-@_containerId">
                                <rect width="100%" height="100%" fill="white"/>
                                <circle cx="140" cy="140" r="@_circleRadius" fill="black"/>
                            </mask>
                        </defs>
                        <rect width="100%" height="100%" fill="rgba(0,0,0,0.6)" mask="url(#circleMask-@_containerId)"/>
                        <circle cx="140" cy="140" r="@_circleRadius" fill="none" stroke="#fff" stroke-width="2" stroke-dasharray="5,5"/>
                    </svg>
                </div>
            </div>
            
            <!-- Compact Controls -->
            <MudStack Spacing="1" Style="width: 280px;">
                <MudSlider @bind-Value="_circleRadius" Min="40" Max="130" Step="5" Color="Color.Primary" Size="Size.Small">
                    Cerc: @_circleRadius px
                </MudSlider>
                <MudSlider @bind-Value="_scale" Min="1.0" Max="3.0" Step="0.1" Color="Color.Secondary" Size="Size.Small">
                    Zoom: @_scale.ToString("F1")x
                </MudSlider>
            </MudStack>
            
            <MudText Typo="Typo.caption" Color="Color.Info">
                Trage sau scroll pentru zoom
            </MudText>
            
            <MudButton Variant="Variant.Text" Color="Color.Secondary" Size="Size.Small"
                       StartIcon="@Icons.Material.Filled.RestartAlt" OnClick="ResetCrop">
                Resetează
            </MudButton>
        }
        else if (!string.IsNullOrEmpty(PreviewUrl))
        {
            <!-- Simple preview for EXISTING image -->
            <MudAvatar Style="width: 150px; height: 150px; border: 3px solid var(--mud-palette-primary);">
                <img src="@PreviewUrl" alt="Profile" style="width: 100%; height: 100%; object-fit: cover;" />
            </MudAvatar>
            <MudText Typo="Typo.caption" Color="Color.Secondary">Poză actuală</MudText>
        }
        else
        {
            <MudAvatar Color="Color.Primary" Style="width: 120px; height: 120px;">
                <MudIcon Icon="@Icons.Material.Filled.AddAPhoto" Size="Size.Large" />
            </MudAvatar>
        }

        <!-- Upload Button -->
        <label for="@_inputId" style="width: 100%; max-width: 280px;">
            <MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.PhotoCamera"
                       Color="Color.Primary" FullWidth="true" Size="Size.Small" HtmlTag="span">
                @(string.IsNullOrEmpty(PreviewUrl) ? "Alege Poză" : (_hasNewImage ? "Alege altă poză" : "Schimbă poza"))
            </MudButton>
        </label>

        <InputFile id="@_inputId" OnChange="HandleFileSelected" accept="image/jpeg,image/png,image/webp" style="display:none;" />

        <MudText Typo="Typo.caption" Color="Color.Default">JPG, PNG, WEBP • Max 5MB</MudText>
    </MudStack>
</MudPaper>

<style>
    .crop-container {
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        touch-action: none;
        overscroll-behavior: contain;
    }
    .crop-container:active { cursor: grabbing !important; }
    .crop-overlay circle { animation: dash 20s linear infinite; }
    @@keyframes dash { to { stroke-dashoffset: -100; } }
</style>

@code {
    [Parameter] public EventCallback<IBrowserFile?> OnFileSelected { get; set; }
    [Parameter] public string? PreviewUrl { get; set; }
    
    private readonly string _inputId = $"profile-pic-{Guid.NewGuid():N}";
    private readonly string _imageId = $"profile-img-{Guid.NewGuid():N}";
    private readonly string _containerId = $"crop-container-{Guid.NewGuid():N}";

    private bool _hasNewImage;
    private double _circleRadius = 100;
    private double _imageOffsetX;
    private double _imageOffsetY;
    private double _scale = 1.0;
    private bool _isDragging;
    private double _lastMouseX;
    private double _lastMouseY;
    private IBrowserFile? _originalFile;
    private DotNetObjectReference<ProfilePictureUpload>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_hasNewImage && !string.IsNullOrEmpty(PreviewUrl))
        {
            try
            {
                _dotNetRef ??= DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("preventScrollOnElement", _containerId, _dotNetRef);
            }
            catch { }
        }
    }

    public async ValueTask DisposeAsync()
    {
        try { await JS.InvokeVoidAsync("allowScrollOnElement", _containerId); } catch { }
        _dotNetRef?.Dispose();
    }

    [JSInvokable]
    public void HandleWheelZoom(bool zoomIn)
    {
        if (!_hasNewImage) return;
        _scale = zoomIn ? Math.Min(_scale + 0.1, 3.0) : Math.Max(_scale - 0.1, 1.0);
        StateHasChanged();
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.File != null)
        {
            _originalFile = e.File;
            _hasNewImage = true;
            ResetCrop();
            if (OnFileSelected.HasDelegate) await OnFileSelected.InvokeAsync(e.File);
        }
    }

    public bool HasNewImage => _hasNewImage;

    public async Task<byte[]?> GetCroppedImageAsync()
    {
        if (string.IsNullOrEmpty(PreviewUrl) || !_hasNewImage) return null;

        try
        {
            const double containerSize = 280.0;
            const double circleCenterX = 140.0;
            const double circleCenterY = 140.0;

            var croppedBase64 = await JS.InvokeAsync<string>("cropImageToCircle",
                PreviewUrl, circleCenterX, circleCenterY, _circleRadius, _scale,
                _imageOffsetX, _imageOffsetY, containerSize, containerSize);

            if (!string.IsNullOrEmpty(croppedBase64))
            {
                var base64Data = croppedBase64.Contains(",") ? croppedBase64.Split(',')[1] : croppedBase64;
                return Convert.FromBase64String(base64Data);
            }
        }
        catch { }
        return null;
    }

    private void ResetCrop()
    {
        _circleRadius = 100;
        _imageOffsetX = 0;
        _imageOffsetY = 0;
        _scale = 1.0;
        _isDragging = false;
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        if (!_hasNewImage) return;
        _isDragging = true;
        _lastMouseX = e.ClientX;
        _lastMouseY = e.ClientY;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (!_isDragging || !_hasNewImage) return;
        _imageOffsetX += e.ClientX - _lastMouseX;
        _imageOffsetY += e.ClientY - _lastMouseY;
        _lastMouseX = e.ClientX;
        _lastMouseY = e.ClientY;
        StateHasChanged();
    }

    private void OnMouseUp(MouseEventArgs e) => _isDragging = false;
}
